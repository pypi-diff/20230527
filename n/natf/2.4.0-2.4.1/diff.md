# Comparing `tmp/natf-2.4.0-py3-none-any.whl.zip` & `tmp/natf-2.4.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,45 +1,45 @@
-Zip file size: 127708 bytes, number of entries: 43
--rw-rw-r--  2.0 unx      337 b- defN 22-Nov-23 03:26 natf/__init__.py
--rw-rw-r--  2.0 unx    51677 b- defN 23-Apr-06 15:24 natf/cell.py
--rw-rw-r--  2.0 unx    17020 b- defN 23-Apr-02 15:25 natf/fispact_input.py
--rw-rw-r--  2.0 unx    20352 b- defN 23-May-25 15:53 natf/fispact_output.py
--rw-rw-r--  2.0 unx      957 b- defN 22-Nov-23 03:26 natf/half_space.py
--rw-rw-r--  2.0 unx    21175 b- defN 23-Apr-19 01:37 natf/material.py
--rw-rw-r--  2.0 unx    35222 b- defN 22-Dec-07 13:52 natf/mcnp_input.py
--rw-rw-r--  2.0 unx    38052 b- defN 22-Dec-07 12:22 natf/mcnp_output.py
--rw-rw-r--  2.0 unx    13879 b- defN 22-Nov-23 03:26 natf/mesh.py
--rw-rw-r--  2.0 unx    75565 b- defN 23-May-25 15:53 natf/natf_functions.py
--rw-rw-r--  2.0 unx    11802 b- defN 23-Jan-27 07:17 natf/nuc_treat.py
--rw-rw-r--  2.0 unx    59559 b- defN 23-May-25 15:53 natf/part.py
--rw-rw-r--  2.0 unx    29321 b- defN 23-Apr-02 15:47 natf/plot.py
--rw-rw-r--  2.0 unx    20178 b- defN 22-Dec-07 12:22 natf/radwaste_standard.py
--rw-rw-r--  2.0 unx    29681 b- defN 23-Jan-19 13:11 natf/settings.py
--rw-rw-r--  2.0 unx     3041 b- defN 22-Nov-23 03:26 natf/source_particle.py
--rw-rw-r--  2.0 unx     3270 b- defN 22-Nov-23 03:26 natf/surface.py
--rw-rw-r--  2.0 unx    29590 b- defN 23-May-25 09:13 natf/utils.py
--rw-rw-r--  2.0 unx        6 b- defN 23-May-25 15:53 natf/version
--rw-rw-r--  2.0 unx      302 b- defN 22-Nov-23 03:26 natf/data/README.md
--rw-rw-r--  2.0 unx     3876 b- defN 22-Nov-23 03:26 natf/data/appendix16
--rw-rw-r--  2.0 unx    17645 b- defN 22-Nov-23 03:26 natf/data/fendl31c_nucs
--rw-rw-r--  2.0 unx    47924 b- defN 22-Nov-23 03:26 natf/data/tendl19c_nucs
--rw-rw-r--  2.0 unx     7711 b- defN 22-Nov-23 03:26 natf/data/energy_groups/ccfe-709.txt
--rw-rw-r--  2.0 unx      115 b- defN 22-Nov-23 03:26 natf/data/energy_groups/photon-24.txt
--rw-rw-r--  2.0 unx     3476 b- defN 22-Nov-23 03:26 natf/data/energy_groups/tripoli-315.txt
--rw-rw-r--  2.0 unx    14339 b- defN 22-Nov-23 03:26 natf/data/energy_groups/ukaea-1102.txt
--rw-rw-r--  2.0 unx     1938 b- defN 22-Nov-23 03:26 natf/data/energy_groups/vitamin-j-175.txt
--rw-rw-r--  2.0 unx      840 b- defN 22-Nov-23 03:26 natf/data/energy_groups/wims-69.txt
--rw-rw-r--  2.0 unx     2110 b- defN 22-Nov-23 03:26 natf/data/fispact_files/FILES-175
--rw-rw-r--  2.0 unx      906 b- defN 22-Nov-23 03:26 natf/data/fispact_files/FILES-709
--rw-rw-r--  2.0 unx    11135 b- defN 22-Dec-06 08:26 natf/radwaste_standards/CHN2018/CHN2018.csv
--rw-rw-r--  2.0 unx      116 b- defN 22-Nov-23 03:26 natf/radwaste_standards/RUSSIAN/RUSSIAN.csv
--rw-rw-r--  2.0 unx     1782 b- defN 22-Nov-23 03:26 natf/radwaste_standards/USNRC/README.md
--rw-rw-r--  2.0 unx     3631 b- defN 22-Nov-23 03:26 natf/radwaste_standards/USNRC/USNRC_EDE_MASS.csv
--rw-rw-r--  2.0 unx      176 b- defN 22-Nov-23 03:26 natf/radwaste_standards/USNRC/USNRC_LL.csv
--rw-rw-r--  2.0 unx      116 b- defN 22-Nov-23 03:26 natf/radwaste_standards/USNRC/USNRC_SL.csv
--rw-rw-r--  2.0 unx     3653 b- defN 22-Nov-23 03:26 natf/radwaste_standards/USNRC_FETTER/USNRC_FETTER.csv
--rw-rw-r--  2.0 unx      580 b- defN 23-May-25 15:54 natf-2.4.0.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-25 15:54 natf-2.4.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx      286 b- defN 23-May-25 15:54 natf-2.4.0.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx        5 b- defN 23-May-25 15:54 natf-2.4.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3557 b- defN 23-May-25 15:54 natf-2.4.0.dist-info/RECORD
-43 files, 586995 bytes uncompressed, 122096 bytes compressed:  79.2%
+Zip file size: 127469 bytes, number of entries: 43
+-rw-rw-r--  2.0 unx      337 b- defN 23-Mar-19 13:19 natf/__init__.py
+-rw-rw-r--  2.0 unx    43597 b- defN 23-May-26 18:27 natf/cell.py
+-rw-rw-r--  2.0 unx    17020 b- defN 23-Mar-19 13:19 natf/fispact_input.py
+-rw-rw-r--  2.0 unx    20352 b- defN 23-May-26 16:28 natf/fispact_output.py
+-rw-rw-r--  2.0 unx      957 b- defN 23-Mar-19 13:19 natf/half_space.py
+-rw-rw-r--  2.0 unx    20539 b- defN 23-May-26 18:27 natf/material.py
+-rw-rw-r--  2.0 unx    35222 b- defN 23-Mar-19 13:19 natf/mcnp_input.py
+-rw-rw-r--  2.0 unx    38052 b- defN 23-Mar-19 13:19 natf/mcnp_output.py
+-rw-rw-r--  2.0 unx    12903 b- defN 23-May-26 18:27 natf/mesh.py
+-rw-rw-r--  2.0 unx    75565 b- defN 23-May-26 16:28 natf/natf_functions.py
+-rw-rw-r--  2.0 unx    11802 b- defN 23-Apr-02 05:34 natf/nuc_treat.py
+-rw-rw-r--  2.0 unx    59489 b- defN 23-May-26 18:27 natf/part.py
+-rw-rw-r--  2.0 unx    29321 b- defN 23-May-17 01:16 natf/plot.py
+-rw-rw-r--  2.0 unx    20178 b- defN 23-May-26 18:23 natf/radwaste_standard.py
+-rw-rw-r--  2.0 unx    29683 b- defN 23-May-26 18:27 natf/settings.py
+-rw-rw-r--  2.0 unx     3041 b- defN 23-Mar-19 13:19 natf/source_particle.py
+-rw-rw-r--  2.0 unx     3270 b- defN 23-Mar-19 13:19 natf/surface.py
+-rw-rw-r--  2.0 unx    31269 b- defN 23-May-26 18:27 natf/utils.py
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-26 18:27 natf/version
+-rw-rw-r--  2.0 unx      302 b- defN 23-Mar-19 13:19 natf/data/README.md
+-rw-rw-r--  2.0 unx     3876 b- defN 23-Mar-19 13:19 natf/data/appendix16
+-rw-rw-r--  2.0 unx    17645 b- defN 23-Mar-19 13:19 natf/data/fendl31c_nucs
+-rw-rw-r--  2.0 unx    47924 b- defN 23-Mar-19 13:19 natf/data/tendl19c_nucs
+-rw-rw-r--  2.0 unx     7711 b- defN 23-Mar-19 13:19 natf/data/energy_groups/ccfe-709.txt
+-rw-rw-r--  2.0 unx      115 b- defN 23-Mar-19 13:19 natf/data/energy_groups/photon-24.txt
+-rw-rw-r--  2.0 unx     3476 b- defN 23-Mar-19 13:19 natf/data/energy_groups/tripoli-315.txt
+-rw-rw-r--  2.0 unx    14339 b- defN 23-Mar-19 13:19 natf/data/energy_groups/ukaea-1102.txt
+-rw-rw-r--  2.0 unx     1938 b- defN 23-Mar-19 13:19 natf/data/energy_groups/vitamin-j-175.txt
+-rw-rw-r--  2.0 unx      840 b- defN 23-Mar-19 13:19 natf/data/energy_groups/wims-69.txt
+-rw-rw-r--  2.0 unx     2110 b- defN 23-Mar-19 13:19 natf/data/fispact_files/FILES-175
+-rw-rw-r--  2.0 unx      906 b- defN 23-Mar-19 13:19 natf/data/fispact_files/FILES-709
+-rw-rw-r--  2.0 unx    11135 b- defN 23-Mar-19 13:19 natf/radwaste_standards/CHN2018/CHN2018.csv
+-rw-rw-r--  2.0 unx      116 b- defN 23-Mar-19 13:19 natf/radwaste_standards/RUSSIAN/RUSSIAN.csv
+-rw-rw-r--  2.0 unx     1782 b- defN 23-Mar-19 13:19 natf/radwaste_standards/USNRC/README.md
+-rw-rw-r--  2.0 unx     3631 b- defN 23-Mar-19 13:19 natf/radwaste_standards/USNRC/USNRC_EDE_MASS.csv
+-rw-rw-r--  2.0 unx      176 b- defN 23-Mar-19 13:19 natf/radwaste_standards/USNRC/USNRC_LL.csv
+-rw-rw-r--  2.0 unx      116 b- defN 23-Mar-19 13:19 natf/radwaste_standards/USNRC/USNRC_SL.csv
+-rw-rw-r--  2.0 unx     3653 b- defN 23-Mar-19 13:19 natf/radwaste_standards/USNRC_FETTER/USNRC_FETTER.csv
+-rw-rw-r--  2.0 unx      580 b- defN 23-May-26 18:28 natf-2.4.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-May-26 18:28 natf-2.4.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx      286 b- defN 23-May-26 18:28 natf-2.4.1.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx        5 b- defN 23-May-26 18:28 natf-2.4.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3557 b- defN 23-May-26 18:28 natf-2.4.1.dist-info/RECORD
+43 files, 578914 bytes uncompressed, 121857 bytes compressed:  79.0%
```

## zipnote {}

```diff
@@ -108,23 +108,23 @@
 
 Filename: natf/radwaste_standards/USNRC/USNRC_SL.csv
 Comment: 
 
 Filename: natf/radwaste_standards/USNRC_FETTER/USNRC_FETTER.csv
 Comment: 
 
-Filename: natf-2.4.0.dist-info/METADATA
+Filename: natf-2.4.1.dist-info/METADATA
 Comment: 
 
-Filename: natf-2.4.0.dist-info/WHEEL
+Filename: natf-2.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: natf-2.4.0.dist-info/entry_points.txt
+Filename: natf-2.4.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: natf-2.4.0.dist-info/top_level.txt
+Filename: natf-2.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: natf-2.4.0.dist-info/RECORD
+Filename: natf-2.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## natf/cell.py

```diff
@@ -42,28 +42,29 @@
                              float('-inf'), float('inf')]  # z-dim
         # activity part, unit: Bq/kg
         # specific activity of nuclides at different interval, shape=(INTV, NUC)
         self._act = np.zeros(shape=(0, 0), dtype=float, order='C')
         self._act_max_contri_nuc = []  # read only
         # specific activity of max contribution nuclide
         self._act_max_contri_value = np.zeros(shape=(0, 0), dtype=float,
-                                            order='C')
+                                              order='C')
         self._act_max_contri_ratio = np.zeros(shape=(0, 0), dtype=float)
         self._total_act = np.zeros(0, dtype=float)
         self._total_alpha_act = np.zeros(shape=(0), dtype=float)
         # decay heat part, unit: kW/kg
         self._decay_heat = np.zeros(shape=(0, 0), dtype=float)
         self._decay_heat_max_contri_nuc = []
         self._decay_heat_max_contri_value = np.zeros(shape=(0, 0), dtype=float)
         self._decay_heat_max_contri_ratio = np.zeros(shape=(0, 0), dtype=float)
         self._total_decay_heat = np.zeros(0, dtype=float)
         # contact dose part,
         self._contact_dose = np.zeros(shape=(0, 0), dtype=float)
         self._contact_dose_max_contri_nuc = []
-        self._contact_dose_max_contri_value = np.zeros(shape=(0, 0), dtype=float)
+        self._contact_dose_max_contri_value = np.zeros(
+            shape=(0, 0), dtype=float)
         self._contact_dose_max_contri_ratio = np.zeros(
             shape=(0, 0), dtype=float)
         self._total_contact_dose = []
         # Clear Index part
         self._ci = np.zeros(shape=(0, 0), dtype=float)
         self._ci_max_contri_nuc = []
         self._ci_max_contri_value = np.zeros(shape=(0, 0), dtype=float)
@@ -91,15 +92,16 @@
             shape=(0, 0), dtype=float)
         self._vllw_chn2018_max_contri_ratio = np.zeros(
             shape=(0, 0), dtype=float)
         self._total_vllw_chn2018 = np.zeros(0, dtype=float)
         #  llw chn2018
         self._llw_chn2018 = np.zeros(shape=(0, 0), dtype=float)
         self._llw_chn2018_max_contri_nuc = []
-        self._llw_chn2018_max_contri_value = np.zeros(shape=(0, 0), dtype=float)
+        self._llw_chn2018_max_contri_value = np.zeros(
+            shape=(0, 0), dtype=float)
         self._llw_chn2018_max_contri_ratio = np.zeros(
             shape=(0, 0), dtype=float)
         self._total_llw_chn2018 = np.zeros(0, dtype=float)
 
         # USNRC
         self._rw_usnrc_index_sum_ll = None
         self._rw_usnrc_index_sum_sl = None
@@ -213,26 +215,26 @@
 
     @property
     def imp_n(self):
         return self._imp_n
 
     @imp_n.setter
     def imp_n(self, value):
-        if value < 0:
-            raise ValueError('imp_n must be a number that no smaller than 0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('imp_n must be a non-negtive value')
         self._imp_n = value
 
     @property
     def imp_p(self):
         return self._imp_p
 
     @imp_p.setter
     def imp_p(self, value):
-        if value < 0:
-            raise ValueError('imp_p must be a number that no smaller than 0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('imp_p must be a non-negtive value')
         self._imp_p = value
 
     @property
     def fill(self):
         return self._fill
 
     @fill.setter
@@ -250,114 +252,84 @@
 
     @u.setter
     def u(self, value):
         if not isinstance(value, int):
             raise ValueError('universe must be an integer')
         if value < 0:
             raise ValueError(
-                'universe must be a number that no smaller than 0')
+                'universe must be a non-negtive value')
         self._u = value
 
     @property
     def vol(self):
         return self._vol
 
     @vol.setter
     def vol(self, value):
-        if not isinstance(value, float):
-            raise ValueError('vol of cell must be a float')
-        if value < 0:
-            raise ValueError('vol must be a float that no smaller than 0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('vol must be a non-negtive value')
         self._vol = value
 
     @property
     def mass(self):
         return self._mass
 
     @mass.setter
     def mass(self, value):
-        if not isinstance(value, float):
-            raise ValueError('mass of cell must be a float')
-        if value < 0:
-            raise ValueError('mass of cell must be a float no smaller than 0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('mass of cell must be a non-negtive value')
         self._mass = value
 
     @property
     def density(self):
         return self._density
 
     @density.setter
     def density(self, value):
-        if not isinstance(value, float):
-            raise ValueError('density of cell must be a float')
-        if value < 0:
-            raise ValueError('density of cell must between 0 and 30')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('density of cell must be an int/float')
         if value > 30:
             print(
                 f'Warning: density of cell {self.id} exceed 30, maybe nonphysical')
         self._density = value
 
     @property
     def neutron_flux(self):
         return self._neutron_flux
 
     @neutron_flux.setter
     def neutron_flux(self, value):
-        if not isinstance(value, list):
-            raise ValueError('neutron_flux of cell must be a list')
+        if not utils.is_non_negtive_array_1d(value):
+            raise ValueError('neutron_flux of cell must be a non-negtive list')
         if len(value) not in [70, 176, 316, 710]:
             raise ValueError('neutron flux should have data of 70/176/316/710, \
                     with the last of total data')
-        for i in range(len(value)):
-            if not isinstance(value[i], float):
-                raise ValueError(
-                    'neutron_flux of cell must be a list of float')
-            if value[i] < 0:
-                raise ValueError('neutron_flux must be a list that each element\
-                        is no smaller than 0.0')
         self._neutron_flux = value
 
     @property
     def neutron_flux_error(self):
         return self._neutron_flux_error
 
     @neutron_flux_error.setter
     def neutron_flux_error(self, value):
-        if not isinstance(value, list):
-            raise ValueError('neutron_flux_error must be a list')
+        if not utils.is_non_negtive_array_1d(value):
+            raise ValueError('neutron_flux_error must be a non-negtive array')
         if len(value) not in [70, 176, 316, 710]:
             raise ValueError('neutron flux should have data of 70/176/316/710, \
                     the last of total data')
-        for i in range(len(value)):
-            if not isinstance(value[i], float):
-                raise ValueError('neutron_flux_error must be a list of float')
-            if value[i] < 0.0 or value[i] > 1:
-                raise ValueError('neutron_flux_error must between 0 and 1')
         self._neutron_flux_error = value
 
     @property
     def gamma_emit_rate(self):
         return self._gamma_emit_rate
 
     @gamma_emit_rate.setter
     def gamma_emit_rate(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('gamma_emit_rate must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('gamma_emit_rate must be a two-dimensional\
-                    ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError('gamma_emit_rate must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('gamma_emit_rate must no smaller than 0.0')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('gamma_emit_rate must be non-negtive 2d array')
         self._gamma_emit_rate = value
 
     @property
     def nuclides(self):
         return self._nuclides
 
     @nuclides.setter
@@ -371,22 +343,16 @@
 
     @property
     def half_lives(self):
         return self._half_lives
 
     @half_lives.setter
     def half_lives(self, value):
-        if not isinstance(value, list):
-            raise ValueError('half_lives must a list')
-        for i in range(len(value)):
-            if not isinstance(value[i], float):
-                raise ValueError('half_lives of nuclides must be float')
-            if value[i] < 0:
-                raise ValueError('half_lives of nuclides should be no smaller\
-                        than 0.0')
+        if not utils.is_non_negtive_array_1d(value):
+            raise ValueError('half_lives must be non-negtive array')
         self._half_lives = value
 
     @property
     def points(self):
         return self._points
 
     @points.setter
@@ -402,34 +368,26 @@
     @aabb_bounds.setter
     def aabb_bounds(self, value):
         if not isinstance(value, list):
             raise ValueError('aabb_bounds must a list')
         if len(self._aabb_bounds) != 6:
             raise ValueError('size of aabb_bounds must be 6')
         for i in range(len(value)):
-            if not (isinstance(value[i], int) or isinstance(value[i], float)):
+            if not utils.is_int_or_float(value[i]):
                 raise ValueError('aabb_bounds of must be float')
         self._aabb_bounds = value
 
     @property
     def act(self):
         return self._act
 
     @act.setter
     def act(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('act must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('act must be a two-dimensional ndarray')
-        try:
-            if value.min() < 0.0:
-                raise ValueError(
-                    f'act must no smaller than 0.0, error data {value.min()}')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('act must be non-negtive 2d array')
         self._act = value.astype(float)
 
     @property
     def act_max_contri_nuc(self):
         return self._act_max_contri_nuc
 
     @property
@@ -446,44 +404,29 @@
 
     @property
     def total_alpha_act(self):
         return self._total_alpha_act
 
     @total_alpha_act.setter
     def total_alpha_act(self, value):
-        if not isinstance(value, type(np.ndarray((0)))):
-            raise ValueError('total_alpha_act must be ndarray')
+        if not utils.is_non_negtive_array_1d(value):
+            raise ValueError('total_alpha_act must be non-negtive array')
         if len(value.shape) != 1:
             raise ValueError(
                 'total_alpha_act must be a one-dimensional ndarray')
-        for i in range(value.shape[0]):
-            if not isinstance(value[i], float):
-                raise ValueError('total_alpha_act must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('total_alpha_act must no smaller than 0.0')
-        except:
-            pass
         self._total_alpha_act = value
 
     @property
     def decay_heat(self):
         return self._decay_heat
 
     @decay_heat.setter
     def decay_heat(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('decay heat must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('decay heat must be a two-dimensional ndarray')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('act must no smaller than 0.0')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('decay heat must be nnon-negtive 2d array')
         self._decay_heat = value.astype(float)
 
     @property
     def decay_heat_max_contri_nuc(self):
         return self._decay_heat_max_contri_nuc
 
     @property
@@ -500,27 +443,16 @@
 
     @property
     def contact_dose(self):
         return self._contact_dose
 
     @contact_dose.setter
     def contact_dose(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('contact_dose must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('contact_dose must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError('contact_dose must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('contact_dose must no smaller than 0.0')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('contact_dose must be non-negtive 2d array')
         self._contact_dose = value.astype(float)
 
     @property
     def contact_dose_max_contri_nuc(self):
         return self._contact_dose_max_contri_nuc
 
     @property
@@ -537,23 +469,16 @@
 
     @property
     def ci(self):
         return self._ci
 
     @ci.setter
     def ci(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('ci must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('ci must be a two-dimensional ndarray')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('ci must no smaller than 0.0')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('ci must be non-negtive 2d array')
         self._ci = value.astype(float)
 
     @property
     def ci_max_contri_nuc(self):
         return self._ci_max_contri_nuc
 
     @property
@@ -570,112 +495,71 @@
 
     @property
     def ci_usnrc(self):
         return self._ci_usnrc
 
     @ci_usnrc.setter
     def ci_usnrc(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
+        if not utils.is_non_negtive_array_2d(value):
             raise ValueError('ci_usnrc must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('ci_usnrc must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError('ci_usnrc must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('ci_usnrc must no smaller than 0.0')
-        except:
-            pass
         self._ci_usnrc = value
 
     @property
     def total_ci_usnrc(self):
         return self._total_ci_usnrc
 
     @property
     def dpa(self):
         return self._dpa
 
     @dpa.setter
     def dpa(self, value):
-        if not isinstance(value, float):
-            raise ValueError('dpa value must be a float number')
-        if value < 0:
-            raise ValueError('dpa value must no smaller than 0.0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('dpa value must be non-negtive value')
         self._dpa = value
 
     @property
     def He_production(self):
         return self._He_production
 
     @He_production.setter
     def He_production(self, value):
-        if not isinstance(value, float):
-            raise ValueError('He_production value must be a float number')
-        if value < 0:
-            raise ValueError('He_production value must no smaller than 0.0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('He_production value must be a non-negtive value')
         self._He_production = value
 
     @property
     def H_production(self):
         return self._H_production
 
     @H_production.setter
     def H_production(self, value):
-        if not isinstance(value, float):
-            raise ValueError('H_production value must be a float number')
-        if value < 0:
-            raise ValueError('H_production value must no smaller than 0.0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('H_production value must be a non-negtive')
         self._H_production = value
 
     @property
     def rw_chn2018_index_sum(self):
         return self._rw_chn2018_index_sum
 
     @rw_chn2018_index_sum.setter
     def rw_chn2018_index_sum(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('rw_chn2018_index_sum must be ndarray')
-        if len(value.shape) != 2:
+        if not utils.is_non_negtive_array_2d(value):
             raise ValueError(
-                'rw_chn2018_index_sum must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError(
-                        'rw_chn2018_index_sum must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError(
-                    'rw_chn2018_index_sum must no smaller than 0.0')
-        except:
-            pass
+                'rw_chn2018_index_sum must be non-negtive 2d array')
         self._rw_chn2018_index_sum = value
 
     @property
     def ci_chn2018(self):
         return self._ci_chn2018
 
     @ci_chn2018.setter
     def ci_chn2018(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('ci_chn2018 must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('ci_chn2018 must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError('ci_chn2018 must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('ci_chn2018 must no smaller than 0.0')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('ci_chn2018 must be non-negtive 2d array')
         self._ci_chn2018 = value
 
     @property
     def ci_chn2018_max_contri_nuc(self):
         return self._ci_chn2018_max_contri_nuc
 
     @property
@@ -696,27 +580,16 @@
 
     @property
     def vllw_chn2018(self):
         return self._vllw_chn2018
 
     @vllw_chn2018.setter
     def vllw_chn2018(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('vllw_chn2018 must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('vllw_chn2018 must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError('vllw_chn2018 must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('vllw_chn2018 must no smaller than 0.0')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('vllw_chn2018 must be non-negtive 2d array')
         self._vllw_chn2018 = value
 
     @property
     def vllw_chn2018_max_contri_nuc(self):
         return self._vllw_chn2018_max_contri_nuc
 
     @property
@@ -733,27 +606,16 @@
 
     @property
     def llw_chn2018(self):
         return self._llw_chn2018
 
     @llw_chn2018.setter
     def llw_chn2018(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('llw_chn2018 must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError('llw_chn2018 must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError('llw_chn2018 must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError('llw_chn2018 must no smaller than 0.0')
-        except:
-            pass
+        if not utils.is_non_negtive_array_2d(value):
+            raise ValueError('llw_chn2018 must be non-negtive 2d array')
         self._llw_chn2018 = value
 
     @property
     def llw_chn2018_max_contri_nuc(self):
         return self._llw_chn2018_max_contri_nuc
 
     @property
@@ -766,102 +628,49 @@
 
     @property
     def total_llw_chn2018(self):
         return self._total_llw_chn2018
 
     @rw_usnrc_index_sum_ll.setter
     def rw_usnrc_index_sum_ll(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('rw_usnrc_index_sum_ll must be ndarray')
-        if len(value.shape) != 2:
+        if not utils.is_non_negtive_array_2d(value):
             raise ValueError(
-                'rw_usnrc_index_sum_ll must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError(
-                        'rw_usnrc_index_sum_ll must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError(
-                    'rw_usnrc_index_sum_ll must no smaller than 0.0')
-        except:
-            pass
+                'rw_usnrc_index_sum_ll must be non-negtive 2d array')
         self._rw_usnrc_index_sum_ll = value
 
     @property
     def rw_usnrc_index_sum_sl(self):
         return self._rw_usnrc_index_sum_sl
 
     @rw_usnrc_index_sum_sl.setter
     def rw_usnrc_index_sum_sl(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
+        if not utils.is_non_negtive_array_2d(value):
             raise ValueError('rw_usnrc_index_sum_sl must be ndarray')
-        if len(value.shape) != 2:
-            raise ValueError(
-                'rw_usnrc_index_sum_sl must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError(
-                        'rw_usnrc_index_sum_sl must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError(
-                    'rw_usnrc_index_sum_sl must no smaller than 0.0')
-        except:
-            pass
         self._rw_usnrc_index_sum_sl = value
 
     @property
     def rw_usnrc_fetter_index_sum(self):
         return self._rw_usnrc_fetter_index_sum
 
     @rw_usnrc_fetter_index_sum.setter
     def rw_usnrc_fetter_index_sum(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('rw_usnrc_fetter_index_sum must be ndarray')
-        if len(value.shape) != 2:
+        if not utils.is_non_negtive_array_2d(value):
             raise ValueError(
-                'rw_usnrc_fetter_index_sum must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError(
-                        'rw_usnrc_fetter_index_sum must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError(
-                    'rw_usnrc_fetter_index_sum must no smaller than 0.0')
-        except:
-            pass
+                'rw_usnrc_fetter_index_sum must be non-negtive 2d array')
         self._rw_usnrc_fetter_index_sum = value
 
     @property
     def rw_russian_index_sum(self):
         return self._rw_russian_index_sum
 
     @rw_russian_index_sum.setter
     def rw_russian_index_sum(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('rw_russian_index_sum must be ndarray')
-        if len(value.shape) != 2:
+        if not utils.is_non_negtive_array_2d(value):
             raise ValueError(
-                'rw_russian_index_sum must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError(
-                        'rw_russian_index_sum must composed of float')
-        try:
-            if value.min() < 0.0:
-                raise ValueError(
-                    'rw_russian_index_sum must no smaller than 0.0')
-        except:
-            pass
+                'rw_russian_index_sum must be non-negtive 2d array')
         self._rw_russian_index_sum = value
 
     def update_material(self, mat):
         """
         Update material information from given material.
         The mid, mat, density will be updated.
         """
```

## natf/material.py

```diff
@@ -73,34 +73,29 @@
 
     @ property
     def atom_density(self):
         return self._atom_density
 
     @ atom_density.setter
     def atom_density(self, value):
-        if not isinstance(value, float) and not isinstance(value, int):
-            raise ValueError('atom_density must be a float')
-        if value < 0:
-            raise ValueError(
-                f'atom_density should be larger than 0, given {value}')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('atom_density {value} not a non-negtive value')
         if value > 1:
             print(
                 f'Warning: atom_density of material {self.id} is larger than 1.0, maybe nonphysical')
         self._atom_density = value
 
     @ property
     def density(self):
         return self._density
 
     @ density.setter
     def density(self, value):
-        if not isinstance(value, float) and not isinstance(value, int):
-            raise ValueError('density should be a float!')
-        if value < 0:
-            raise ValueError('density should be larger than 0!')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('density {value} not a non-negtive value')
         if value > 30:
             print(
                 f'Warning: density of material {self.id} exceed 30, maybe nonphysical')
         self._density = value
 
     @ property
     def mcnp_material_nuclide(self):
@@ -203,39 +198,31 @@
 
     @ property
     def fispact_material_atoms_kilogram(self):
         return self._fispact_material_atoms_kilogram
 
     @ fispact_material_atoms_kilogram.setter
     def fispact_material_atoms_kilogram(self, value):
-        if not isinstance(value, list):
+        if not utils.is_non_negtive_array_1d(value):
             raise ValueError(
-                'fispact_material_atoms_kilogram should be a list')
-        for i in range(len(value)):
-            if not isinstance(value[i], float) and not isinstance(value[i], int):
-                raise ValueError(
-                    'fispact_material_atoms_kilogram should be a list of float/int')
+                'fispact_material_atoms_kilogram {value} not a non-negtive 1-d array')
         if len(self._fispact_material_nuclide) != 0 and len(value) != len(self._fispact_material_nuclide):
             raise ValueError(
                 'the length of fispact_material_atoms_kilogram should equals to the length of fispact_material_nuclide!')
         self._fispact_material_atoms_kilogram = value
 
     @ property
     def fispact_material_grams_kilogram(self):
         return self._fispact_material_grams_kilogram
 
     @ fispact_material_grams_kilogram.setter
     def fispact_material_grams_kilogram(self, value):
-        if not isinstance(value, list):
+        if not utils.is_non_negtive_array_1d(value):
             raise ValueError(
-                'fispact_material_grams_kilogram should be a list')
-        for i in range(len(value)):
-            if not isinstance(value[i], float) and not isinstance(value[i], int):
-                raise ValueError(
-                    'fispact_material_grams_kilogram should be a list of float/int')
+                'fispact_material_grams_kilogram {value} not a non-negtive 1-d array')
         if len(self._fispact_material_nuclide) != 0 and len(value) != len(self._fispact_material_nuclide):
             raise ValueError(
                 'the length of fispact_material_grams_kilogram should equals to the length of fispact_material_nuclide!')
         self._fispact_material_grams_kilogram = value
 
     def mcnp2fispact(self):
         """
```

## natf/mesh.py

```diff
@@ -1,12 +1,13 @@
 #!/usr/bin/env python3
 # -*- coding:utf-8 -*-
 
 import numpy as np
 from natf.material import Material
+from natf import utils
 
 
 class Mesh(object):
     """class Mesh"""
 
     def __init__(self):
         self._geom = ''  # xyz/cyl
@@ -66,105 +67,105 @@
 
     @property
     def xmin(self):
         return self._xmin
 
     @xmin.setter
     def xmin(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('xmin of mesh must be float')
         self._xmin = value
 
     @property
     def xmax(self):
         return self._xmax
 
     @xmax.setter
     def xmax(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('xmax of mesh must be float')
         self._xmax = value
 
     @property
     def ymin(self):
         return self._ymin
 
     @ymin.setter
     def ymin(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('ymin of mesh must be float')
         self._ymin = value
 
     @property
     def ymax(self):
         return self._ymax
 
     @ymax.setter
     def ymax(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('ymax of mesh must be float')
         self._ymax = value
 
     @property
     def zmin(self):
         return self._zmin
 
     @zmin.setter
     def zmin(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('zmin of mesh must be float')
         self._zmin = value
 
     @property
     def zmax(self):
         return self._zmax
 
     @zmax.setter
     def zmax(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('zmax of mesh must be float')
         self._zmax = value
 
     @property
     def rmin(self):
         return self._rmin
 
     @rmin.setter
     def rmin(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('rmin of mesh must be float')
         self._rmin = value
 
     @property
     def rmax(self):
         return self._rmax
 
     @rmax.setter
     def rmax(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('rmax of mesh must be float')
         self._rmax = value
 
     @property
     def tmin(self):
         return self._tmin
 
     @tmin.setter
     def tmin(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('tmin of mesh must be float')
         self._tmin = value
 
     @property
     def tmax(self):
         return self._tmax
 
     @tmax.setter
     def tmax(self, value):
-        if not isinstance(value, float):
+        if not utils.is_int_or_float(value):
             raise ValueError('tmax of mesh must be float')
         self._tmax = value
 
     @property
     def origin(self):
         return self._origin
 
@@ -211,42 +212,36 @@
 
     @property
     def vol(self):
         return self._vol
 
     @vol.setter
     def vol(self, value):
-        if not isinstance(value, float):
-            raise ValueError('vol of mesh must be float')
-        if value < 0.0:
-            raise ValueError('vol must not smaller than 0.0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('vol of mesh must be non-negtive float')
         self._vol = value
 
     @property
     def mass(self):
         return self._mass
 
     @mass.setter
     def mass(self, value):
-        if not isinstance(value, float):
-            raise ValueError('mass of mesh must be float')
-        if value < 0.0:
-            raise ValueError('mass must not smaller than 0.0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('mass of mesh must be non-negtive float')
         self._mass = value
 
     @property
     def density(self):
         return self._density
 
     @density.setter
     def density(self, value):
-        if not isinstance(value, float):
-            raise ValueError('density of mesh must be float')
-        if value < 0.0:
-            raise ValueError('density must not smaller than 0.0')
+        if not utils.is_int_or_float(value):
+            raise ValueError('density {value} not non-negtive float')
         self._density = value
 
     @property
     def mesh_cell_list(self):
         return self._mesh_cell_list
 
     @mesh_cell_list.setter
@@ -346,38 +341,29 @@
 
     @property
     def packing_factor(self):
         return self._packing_factor
 
     @packing_factor.setter
     def packing_factor(self, value):
-        if not isinstance(value, float):
-            raise ValueError('packing_factor of mesh must be float')
-        if value < 0.0:
-            raise ValueError('packing_factor must not smaller than 0.0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('packing_factor {value} not non-negtive value')
         self._packing_factor = value
 
     @property
     def neutron_flux(self):
         return self._neutron_flux
 
     @neutron_flux.setter
     def neutron_flux(self, value):
-        if not isinstance(value, list):
-            raise ValueError('neutron_flux of cell must be a list')
+        if not utils.is_non_negtive_array_1d(value):
+            raise ValueError('neutron_flux of cell must be a non-negtive list')
         if len(value) != 176:
             raise ValueError(
                 'neutron flux should have data of 176, with the last of total data')
-        for i in range(len(value)):
-            if not isinstance(value[i], float):
-                raise ValueError(
-                    'neutron_flux of mesh must be a list of float')
-            if value[i] < 0:
-                raise ValueError(
-                    'neutron_flux of mesh must be a list that each element is no smaller than 0.0')
         self._neutron_flux = value
 
     @property
     def neutron_flux_error(self):
         return self._neutron_flux_error
 
     @neutron_flux_error.setter
@@ -396,25 +382,17 @@
 
     @property
     def gamma_emit_rate(self):
         return self._gamma_emit_rate
 
     @gamma_emit_rate.setter
     def gamma_emit_rate(self, value):
-        if not isinstance(value, type(np.ndarray((0, 0)))):
-            raise ValueError('gamma_emit_rate must be ndarray')
-        if len(value.shape) != 2:
+        if not utils.is_non_negtive_array_2d(value):
             raise ValueError(
-                'gamma_emit_rate must be a two-dimensional ndarray')
-        for i in range(value.shape[0]):
-            for j in range(value.shape[1]):
-                if not isinstance(value[i, j], float):
-                    raise ValueError('gamma_emit_rate must composed of float')
-        if value.min() < 0.0:
-            raise ValueError('gamma_emit_rate must no smaller than 0.0')
+                'gamma_emit_rate {value} not non-negtive 2-d array')
         self._gamma_emit_rate = value
 
     @property
     def mat(self):
         return self._mat
 
     @mat.setter
```

## natf/part.py

```diff
@@ -123,18 +123,16 @@
 
     @property
     def mass_flow_rate(self):
         return self._mass_flow_rate
 
     @mass_flow_rate.setter
     def mass_flow_rate(self, value):
-        if not isinstance(value, float):
-            raise ValueError('mass flow rate of the part must be float')
-        if value < 0.0:
-            raise ValueError('mass flow rate must >= 0.0')
+        if not utils.is_non_negtive_value(value):
+            raise ValueError('mass flow rate {value} not non-negtive value')
         self._mass_flow_rate = value
 
     @property
     def node_part_count(self):
         return self._node_part_count
 
     @node_part_count.setter
```

## natf/settings.py

```diff
@@ -769,7 +769,9 @@
     part_info = np.array(df.loc[df['Parts'] == part_name], dtype=str).flatten()
     irr_time = float(part_info[2])
     cooling_times_s = []
     for i in range(3, len(cols), 2):
         cooling_times_s.append(part_info[i])
     cooling_times = [float(x) for x in cooling_times_s]
     return irr_time, cooling_times
+
+
```

## natf/utils.py

```diff
@@ -1053,10 +1053,72 @@
             super().next()
 
     def finish(self):
         if self.show:
             super().finish()
 
 
+def is_int_or_float(number):
+    """Check whether a number is int or float"""
+    if isinstance(number, int) or isinstance(number, np.int_) or isinstance(number, float) or isinstance(number, np.float_):
+        return True
+    else:
+        return False
+
+
+def is_non_negtive_value(number):
+    if is_int_or_float(number) and number >= 0:
+        return True
+    else:
+        return False
+
+
+def is_non_negtive_array_1d(arr):
+    """Check whether an array contains non-negtive values"""
+    # check shape
+    try:
+        for item in arr:
+            try:
+                for jtem in item:
+                    raise ValueError(f"{arr} at least 2-d")
+            except (TypeError):
+                break
+            except (ValueError):
+                raise TypeError(f"{arr} at least 2-d")
+    except:
+        raise TypeError(f"input not 1-d array or list")
+    try:
+        if min(arr) < 0:
+            return False
+        else:
+            return True
+    except:
+        return False
+
+
+def is_non_negtive_array_2d(arr):
+    """Check whether an array contains non-negtive values"""
+    # check shape
+    try:
+        for item in arr:
+            for jtem in item:
+                try:
+                    for ktem in jtem:
+                        raise ValueError(f"{arr} at least 3-d")
+                except (TypeError):
+                    break
+                except (ValueError):
+                    raise TypeError(f"{arr} at least 3-d")
+    except:
+        raise TypeError(f"{arr} is not 2-d array")
+    # check non-negtive value
+    for item in arr:
+        if is_non_negtive_array_1d(item):
+            pass
+        else:
+            return False
+    return True
+
+
 # codes for test functions
 if __name__ == '__main__':
     pass
```

## natf/version

```diff
@@ -1 +1 @@
-2.4.0
+2.4.1
```

## Comparing `natf-2.4.0.dist-info/METADATA` & `natf-2.4.1.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: natf
-Version: 2.4.0
+Version: 2.4.1
 Summary: Nuclear Analysis toolkit for Fusion with coupling of MCNP and FISPACT
 Home-page: https://github.com/zxkjack123/NATF
 Author: Xiaokang Zhang
 Author-email: zxkjack123@163.com
 License: MIT
 Platform: UNKNOWN
 Classifier: Programming Language :: Python :: 3
```

